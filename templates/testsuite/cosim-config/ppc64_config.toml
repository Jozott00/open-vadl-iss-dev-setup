# SPDX-FileCopyrightText : Â© 2025 TU Wien <vadl@tuwien.ac.at>
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# General settings for the QEMU plugin system which set up the co-simulation
[qemu]

# The path to the compiled cosimulation qemu-plugin
plugin="/work/iss/build/contrib/plugins/libcosimulation.so"

# Whether to ignore registers that are not defined by a [qemu.gdb_reg_map] mapping
# This option is useful to test the current implementation of a simulator which might not yet have all registers implemented against another (complete) implementation
# Filters in conjunction with `ignore_registers`
ignore_unset_registers = true

# Ignore specific registers
# Filters in conjunction with `ignore_unset_registers`
ignore_registers = [ "x3" ]


# Defines a list of clients to test against
# A single client is also possible, e.g. to check if a crash or similar occurs
# In most use-cases, 2 clients (one test-simulator and one reference-simulator) are used
[[qemu.clients]]

# Optional: A custom name for a client
# Will default to the index of the client in this list
name = "VADL"

# The executable of the ISS
exec = "/work/iss/build/qemu-system-ppc64sfs"

# The path to the compiled file to use for testing
test_exec="./test-execs/test_vadl"

# "bios" | "kernel": Defines where the test-executable is passed to when starting the QEMU-client
pass_test_exec_to = "bios"

# Applies additional arguments to the ISS-executable, e.g. `qemu-system-riscv64 -nographic -d plugin`
additional_args = [
    "-plugin",
    "/work/iss/build/contrib/plugins/libstoptrigger.so,addr=0xFC",
    "-nographic",
    "-d", "plugin"
]

# A hint for the cosimulator whether the client uses little or big endian
# This setting does not change the execution in any way and is only used in case clients have differing endianess
# but should still be compared "correctly"
# This field is optional, not setting it means the register-data is being compared left-to-right (i.e. big-endian by default)
# This setting also *does not* have an effect on tracing, data will still be stored in the original endianess
endian = "little"

# The following three options configure which instructions from the `test_exec` executable should actually be tested.
# NOTE: Only applies to `layer = "insn" | "tb-strict"`
# NOTE: This option is must be set per client to be able to account for different setup-codes per ISS
# Skips the first n instructions
skip_n_instructions = 0

# Settings for running the qemu-clients with gdb-debugging enabled.
# Use these settings when possible instead of configuring the flags in the additional_args array since otherwise the runner will mark the client as finished because it did not respond in time.
[qemu.clients.gdb]
enable = false
# The target_type can be optionally set ("chardev" | "port"), default is "chardev"
# For reference see the QEMU GDB usage documentation: https://qemu-project.gitlab.io/qemu/system/gdb.html
# For more info regarding chardev/unix sockets see: https://qemu-project.gitlab.io/qemu/system/gdb.html#using-unix-sockets
# Using a chardev is preferred to ensure that the target is always available for cosimulation
# NOTE: It is not necessary (and will lead to errors if done anyway) to manually create the char-device, simply use a path that is available and
#		QEMU will automatically handle creating the device-file.
# If target_type is "port" then simply enter the port (e.g. "tcp:1234") into the remote_target field, QEMU will try to listen on the port automatically
target_type = "chardev"
remote_target = "/tmp/gdb-cosim-VADL"

[[qemu.clients]]
name = "UPSTREAM"

exec = "/work/iss/build/qemu-system-ppc64"

test_exec="./test-execs/test_upstream"

pass_test_exec_to = "bios"

additional_args = [
    "-plugin",
    "/work/iss/build/contrib/plugins/libstoptrigger.so,addr=0xFC",
    "-nographic",
    "-M", "pseries",
    "-cpu", "POWER10",
    "-d", "plugin"
]

skip_n_instructions = 0

[qemu.clients.gdb]
enable = false
target_type = "chardev"
remote_target = "/tmp/gdb-cosim-VADL"


# Defines a custom map where the key (e.g. x0) is mapped to another value (e.g. zero)
[qemu.gdb_reg_map]
r0 = "x0"
r1 = "x1"
r2 = "x2"
r3 = "x3"
r4 = "x4"
r5 = "x5"
r6 = "x6"
r7 = "x7"
r8 = "x8"
r9 = "x9"
r10 = "x10"
r11 = "x11"
r12 = "x12"
r13 = "x13"
r14 = "x14"
r15 = "x15"
r16 = "x16"
r17 = "x17"
r18 = "x18"
r19 = "x19"
r20 = "x20"
r21 = "x21"
r22 = "x22"
r23 = "x23"
r24 = "x24"
r25 = "x25"
r26 = "x26"
r27 = "x27"
r28 = "x28"
r29 = "x29"
r30 = "x30"
r31 = "x31"

cr = "cr"
msr = "msr"
xer = "xer"
lr = "lr"
ctr = "ctr"
#tb = "tb"
tar = "tar"
srr0 = "srr0"
srr1 = "srr1"

# Defines the test-source and how to test
[testing]

# The testing-protocol defines how the clients are run and tested against eachother
[testing.protocol]
# Defines an *execution-step* of a test-run.
# "insn": The execution-step is the *execution of a single instruction*, e.g. `addi t4,zero,2`.
#		  This layer is independent of how an ISS generates translation-blocks for qemu.
#		  This is the most thorough but also slowest option.
#
# NOTE: the following is not yet implemented.
# "tb":   The execution-step is the *execution of a single or multiple translation-blocks*.
#		  Multiple translation-blocks might be executed in a single step if another client executed a larger.
#		  (but potentially equivalent to multiple smaller TBs) translation-block.
#		  This allows instruction-equivalent clients to "synchronize" even if the generated translation-blocks differ.
#		  This option is faster than "insn" but less thorough.
#
# "tb-strict": The execution-step is the *execution of a single translation-blocks*.
#			   The same as "tb" but without the synchronization logic. Meaning that equal translation-blocks are assumed.
#			   This option is useful if the instructions of the ISS are already correct and the TB-Block generator needs to be tested.
layer = "insn"

# "lockstep": All clients are run and compared one *execution-step* at a time.
# 			  This means that the test will exit on the first divergence (or at the end if no diffs where found)
# Currently, this is the only implemented mode.
mode = "lockstep"

# Execute all remaining instructions (overrides `stop_after_n_instructions` if set to true)
execute_all_remaining_instructions = false

# Execute the next (after skipped) n instructions
stop_after_n_instructions = 100

# Where the test result should be saved and in which format
[testing.protocol.out]
# file = "./cosim-run/result/result.json"

# "short" | "full"
verbosity = "full"

[logging]
enable = false
# tracing log-levels as defined here: https://docs.rs/tracing/latest/tracing/struct.Level.html#implementations
level = "info"

# The directory will also contain files for the stdout and stderr of each client
dir = "/work/testsuite/cosim-logs"
file = "cosim.log"

# Clears the logfile every time the program is run
clear_on_rerun = true

[dev]
# Prints the loaded configuration if set to true and exits
dry_run = false
